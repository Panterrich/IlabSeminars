# 1. WSL, консоль

## Семинар

Linux - операционная система, стандарт де-факто во многих областях разработки. Является очень гибкой системой и предоставляет по-настоящему мощные и удобные инструменты для работы.

### WSL

Если у вас стоит операционная система Windows, то не нужно спешить ставить Linux вместо Windows или ставить вторую систему рядом. В Windows уже достаточно давно существует Windows Subsystem for Linux (WSL), которая в последние годы всё более активно развивается.

WSL - это функциональность Windows, которая позволяет использовать окружение Linux без виртуальной машины или наличия второй системы рядом (dual-boot).

#### Установка

> Draft
>
> Следуйте [инструкции](https://learn.microsoft.com/en-us/windows/wsl/install)

### Подключение к WSL с помощью VS Code

> Draft
>
> Рассказать про VS Code SSH Remote Control + WSL Remote (или как там) + показать как связываются файловые системы.

### Терминал

Терминал - один из основных инструментов, который помогает быстро управлять проектом, исполняя консольные команды/приложения. Это и сборка проекта, и создание файлов, и контроль системы версий проекта (тема следующего семинара), и многие прочие вещи.

> [!WARNING]
> Здесь и дальше предполагается, что либо у вас Linux или MacOs, либо вы используете WSL для Windows.

### Команды для взаимодействия с файловой системой

Первое то, с чем необходимо познакомиться - это то, как необходимо работать с файловой системой в терминале. Терминал открывается сразу по какому-то определенному пути, по-умолчанию, в домашней директории.

---

#### 1. Команда `pwd`

`pwd` (present working directory) - это команда, которая показывает в какой рабочей директории сейчас находимся.

Пример пути на Linux:
```
$ pwd
/home/panterrich
```

Пример пути на MacOs:
```
$ pwd
/Users/panterrich
```

Это пути домашних директорий пользователя `panterrich`. Домашняя директория текущего пользователя также обозначается как `~`.

Файловая система имеет древовидную структуру. И пути в этой структуре можно задавать двумя способами:
1. Абсолютные пути - пути, которые задаются от корня `/`.
   - Пример: результат команды `pwd`.
2. Относительные пути - пути, которые задаются относительно текущей директории, т.е. относительно абсолютного пути, например, которые возвращает команда `pwd`.
   - Пример: будет рассмотрен подробно чуть позже.

----

#### 2. Команда `cd` и утилита `ls`

Теперь поговорим о том, как можно менять текущую директорию, но для этого сначала посмотрим, что хранится в нашей директории.

> `ls` (list) - утилита, которая показывает содержимое по указанному пути, по-умолчанию, путь текущей директории.

![Пример выполнения утилиты ls](images/ls.png)

Видим следующее содержание директории: 2 текстовых файла и 2 поддиректории. Давайте получим более подробную информацию о файлах в данной директории.

![Пример выполнения утилиты ls -l](images/ls-l.png)

В первой строке написано количество блоков дискового пространство, которое заняла директория. Обычно блок равен 1КБ. Дальше на каждой строке написано: является ли данный файл директорией (d) и маска прав.

Традиционно выделяют три права доступа к файлу: чтение, запись и исполнение. Для директорий эти права означают немного другое, нежели для регулярных файлов: чтение - получить содержимое, т.е. список файлов, запись - добавление, удаление, изменение файлов в директории, исполнение - переход в эту директорию.

Дальше выделяют три группы доступа: владелец (owner), группа (group), остальные (other).
Такое разделение прав доступа позволяет обеспечивать информационный безопасность. Более подробно это всё будет разбираться в дальнейших курсах.

Также здесь указан владелец и группа файла, размер файла в байтах, дата последнего изменения.

Давайте теперь перейдем в какую-нибудь директорию.

> `cd` (change directory) - команда, которая осуществляет переход в указанную директорию.

![Пример выполнения команды cd](images/cd.png)

Данная директория пустая. А как теперь нам выйти из неё? Перезапускать терминал? Писать новый абсолютный путь? Да, но нет. Как уже упоминалось ранее, файловую структуру можно представить в виде дерева. И по этому дереву можно ходить назад.

Применяем магию и покажем скрытые файлы

![Пример выполнения утилита ls -la](images/ls-la.png)

Оказывается директория не пустая: в ней содержатся две скрытые директории `.` и `..`. Данные скрытые директории есть в каждой директории. Что же они обозначают?

- `.` - текущая директория
- `..` - предшествующая директория

С помощью данных директорий можно писать относительные пути, делать переходы назад и тд.

![Пример выполнения команды cd с относительным путём](images/cd_rel.png)

---

#### 3. Утилита `clear`

Полезная утилита для очистки окна терминала.

---

#### 4. Утилита `cat`

Показывает содержимое файла.

Пример использования:

```
$ cat example.txt
Lorem ipsum dolor sit amet, consectetur adipiscing elit.
```

---

#### 5. Утилита `touch`

Используется для установки времени последнего изменения или доступа, а также для создания пустых файлов.

Пример использования:

```
# Создали пустой файл
$ touch myfile.txt

# Изменили дату последнего изменения и доступа на 8:46:26 31 января 2007 г.
$ touch -t 200701310846.26 myfile.txt
```

---

#### 6. Утилита `mkdir`

Используется для создания директорий.

Пример использования:

```
# Создаём директорию 'dir1'
$ mkdir dir1

# Создание нескольких директорий
$ mdkir dir1 dir2 dir3
```

#### 7. Утилита `nano`

Один из популярных консольных текстовых редакторов, более простой, чем vi/vim. Часто при работе с консольными утилитами/командами придётся работать с текстовым редактором.

Для начала редактирования достаточно написать следующее:
```
$ nano <filename>
```

Обычно данный редактор используется для достаточно простых вещей, поэтому следует запомнить механизм работы горячих клавиш и как сохранить файл после изменений и выйти из редактора.

![Пример интерфейса редактора nano](images/nano.png)

Все горячие клавиши в nano работают с использованием `Ctrl`. Так можно получить дополнительную справочную информацию о всех горячих клавишах с помощью `Ctrl+G`. Основные подсказки также продублированы снизу.

На данном этапе знакомства со всеми командами достаточно запомнить основное действие: запись в файл `Ctrl+O`, закрытие редактора `Ctrl+X`. Если запись в файл не была произведена, то при закрытии редактор предложит сохранить изменения.

#### 8. Манипуляции с файлами: `cp`, `mv` и `rm`

Основные команды для работы с файлами:

1. `cp` (copy) - копирование
2. `mv` (move) - перемещение
3. `rm` (remove) - удаление

```
# копируем файл test1.txt в test2.txt
$ cp test1.txt test2.txt

# копируем файл test1.txt в test_dir
$ cp test1.txt test_dir

# копирование директории test_dir в test_dir_copy
$ cp -r test_dir test_dir_copy

```

Тоже самое и с `mv`, то будет происходить перемещение файла, а не копирование.

> [!WARNING]
> По умолчанию, `cp` и `mv` перезаписывают файлы, чтобы этого не происходило есть флаг `-i`, который включает интерактивный режим - будут спрашивать: перезаписать файл или нет.

```
# удаление файла test1.txt
$ rm test1.txt

# удаление файлов в директории
$ rm -r test_dir
```

Часто можно увидеть в примерах употребляют флаг `-f`, который подавляет возможные предупреждения, именно поэтому надо быть с ним осторожным.

> [!WARNING]
> Прежде, чем делать какое-либо удаление, проверяйте, что вы удаляете, подменяя `rm` на `ls`, потому что `rm` не предполагает наличия "корзины", восстановить файлы будет крайне сложно, а часто и просто невозможно.

> [!WARNING]
> Никогда не пытайтесь выполнить следующую команду `rm -rf /`, хорошо, если она не отработает в силу защиты системы, иначе останетесь не только без OS, но ещё и без своих проектов. Не забывайте точку.

#### 9. Компиляторы `gcc` и `g++`

GNU Compiler Collection (GCC) - набор компиляторов, имеет несколько фронтедов для разных языков программирования. Остановимся на двух основных:

* `gcc` (GNU C Compiler) - фронтенд для языка C.
* `g++` - фротенд для языка С++.

Поскольку стандарт и компилятор С++ строже С, поэтому в нашем курсе мы будет пользоваться `g++`, но при этом будет писать на С.

Рассмотрим базовый синтаксис:

```
$ g++ <sources.cpp ...> -o <output>
```

Перечисляем все `.cpp` файлы и после флага `-o` пишем имя желаемого бинарника, который в дальнейшем будем запускать.

Для запуска необходимо в консоли просто написать путь до файла, консоль по умолчанию ищет команды в директориях, которые перечислены в переменной окружения `$PATH`, поэтому необходимо указать так же путь с текущей директорией.

Пример:

<img src="images/g++.png" width="500">

Более подробно о компиляции и как более профессионально собирать проект будет в дальнейших семинарах.

#### 10. Команда `echo`

Выводит в стандартный поток вывода поданную строку. На первый взгляд достаточно бесполезная команда, но часто может использовать в скриптах для отображения строк, а также для автоматизации тестов.

Пример:
```
$ echo "(⁎˃ᆺ˂)"
(⁎˃ᆺ˂)
```

#### 11. Перенаправление ввода и вывода

Одна из полезных функциональностей потоков ввода и вывода это возможность их перенаправить.

Для начала вспомним какие стандартные потоки у нас есть:

1. stdin (0) - поток ввода
2. stdout (1) - поток вывода
3. stderr (2) - поток ошибок

Можно, например, делать так: направить поток ошибок из вашей программы в лог-файл.

Рассмотрим все возможности перенаправления:

1. `< file` — использовать файл как источник данных для стандартного потока ввода.
2. `> file` — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
3. `2> file` — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
4. `>> file` — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
5. `2>> file` — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
6. `&>file или >&file` — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >file 2>&1.

Возможные примеры использования:
1. Если приложение работает с пользователем по средством `stdin`, то для более удобного тестирования приложения, можно направить в `stdin` заранее заготовленный файл.
2. Также можно автоматически сохранить ошибки приложения в файл, если оно пишет их в stderr.

Ещё один мощный инструмент, который часто используют, это каналом (pipe) `|`. Его также часто называют конвейером. Он позволяет перенаправить вывод одного приложение на вход другого.

Пример использования:

```
$ cat file.txt | ./hello_world

# это эквивалентно
$ ./hello_world < file.txt
```

Более полезные примеры покажем дальше.

#### 12. Утилиты `find` и `grep`

`find` - утилита поиска файлов по имени и другим свойствам, используемая в UNIX‐подобных операционных системах

```
# Сначала указываем директорию, где искать,
# а затем критерий поиска и сам паттерн поиска
$ find <dir> -<search criteria> <pattern>
```

Самым популярным критерием поиска является имя файла: `-name`

```
# найти все текстовые файлы в текущей директории
$ find . -name "*.txt"
./example_copy.txt
./example.txt
./test.txt
```

Для тех, кто не знаком с регулярными выражениями, я сделаю отдельный семинар, но сейчас достаточно просто знать, что в пути файлов `*` означает любой символ, кроме `/`, не в пути файла - просто любой символ.

Критерии поиска являются фильтрами, поэтому если их не написать будет выведен список всех файлов (директории тоже являются файлами).

```
$ find .
.
./example_copy.txt
./images
./examples
./example.txt
./hello_world.cpp
./test.txt
./hello
```

Критерии отбора можно совмещать, объединять и исключать с помощью вспомогательных флагов:

```
# Вывести все файлы, которые имеют расширение не .txt, и
# текстовые файлы, которые имеют префикс "test"
$ find . -not -name "*.txt" -o -name "*.txt" -name "test*"
.
./images
./examples
./hello_world.cpp
./test.txt
./hello
```

Теперь перейдем к не менее мощному инструменту - `grep`.
Утилита ищет подстроки в заданных файлах, соответствующих заданному шаблону (обычно регулярному выражению)

В данном примере не будут разбираться сами регулярные выражения, но покажу несколько примеров использования данной утилиты

```
# Поиск всех строк, содержащих слово "error" в log.txt
$ grep "error" log.txt
...

# Теперь поиск не учитывает регистр слова "error"
$ grep -i "error" log.txt
...

# Поиск количества строк с ошибками в файлах с логами
$ grep -c "error" *.log
10

# Поиск всех строк, содержащих слово "success", в выводе ls
$ ls -l | grep "success"
...
```

#### 13. Утилита `xargs`

Утилита `xargs` используется для построения и выполнения команд на основе списка аргументов, получаемых из стандартного ввода, именно поэтому её часто используют в связки с конвейером, после команда `ls`, `grep` и `find`.

```
# Утилита wc -l подсчитывает количество строчек для каждого файла.
$ ls *.txt | xargs wc -l
```

Также `xargs` поддерживает placeholders, подстановку аргументов в конкретных местах, выглядит это следующим образом:

```
# Создаётся список значений от 1 до 5, затем передаётся в xargs и
# добавляется placeholder '{}', который будет заменяться текущим аргументом,
# флаг -n нужен, чтобы гарантировать, что xargs будет обрабатывать каждый аргумент отдельно,
# а не всю строку целиком
$ echo {1..5} | xargs -n 1 -I {} echo "Item: {}"
Item: 1
Item: 2
Item: 3
Item: 4
Item: 5
```

#### 14. Утилиты `head` и `tail`

`head` показывает первые десять строк файла, `tail` последние десять строк. Можно также с помощью флага `-n` указать количество выводимых строк, или с помощью флага `-с` количество строк в байтах.

Бывает полезным для отображения куска однородного файла, например, `.csv`, или отобразить конец файла логов.

#### 15. Утилита `diff`

Сравнивает как отдельные файлы, так и каталоги.

![Пример работы diff](images/diff.png)

Бывает полезно сравнить выходные данные двух версий программ, или же с эталонными результатами.

#### 16. Утилита `man`

Утилита `man` является основным источником информации при работе со стандартной библиотекой C и API Linux.
С помощью man вы найдёте наиболее подробное описание той или иной функции.

`man` разделен на 8 разделов:

1. Прикладные программы и команды терминала
2. Системные вызовы (функции на языке С)
3. Библиотечные вызовы (функции различных библиотек, установленных в систему)
4. Специальные файлы устройств (файлы /dev/*)
5. Форматы файлы и их соглашения
6. Игры
7. Различные описания, соглашения и прочее
8. Команды администрирования системы

Номер страницы (раздела) задаётся перед запрашиваемой страницей.
Если страница не указана, начинается поиск с первого раздела.

```
# найдётся в разделе 1
$ man write

# укажем явно, что ищем системный вызов
$ man 2 write
```

#### 17. Команда `history`

Команда оболочки терминала, которая отображает историю последних введенных команд.
Сама история обычно хранится в домашней директории в файлах, которые зависят от оболочки терминала, например, `.bash_history` или `.zsh_history`.

Бывает полезно посмотреть раннее введенную команду.

```
$ history
...
 2236  echo 123
 2237  echo "123 _ 456"
 2238  echo "/ᐠ｡ꞈ｡ᐟ\."
 2239  echo "/ᐠ｡ꞈ｡ᐟ\." >> text.txt
```

```
# показать последние 3 команд
$ history 3
 2237  echo "123 _ 456"
 2238  echo "/ᐠ｡ꞈ｡ᐟ\."
 2239  echo "/ᐠ｡ꞈ｡ᐟ\." >> text.txt
```

```
# очистка истории
$ history -c
```


## Самостоятельная работа

### Теоретическая часть

Многие из рассмотренных команд и утилит имеют дополнительные флаги. С помощью `man` ответьте на следующие вопросы:

> [!WARNING]
> Очень важно научиться читать `man`, так как именно он обладает полной информацией о данных командах и утилитах.
> Часто так можно узнать много важных нюансов, которые любят опускать при ответах на вопросы в Интернете,
> поэтому постарайтесь не гуглить ответы на данные вопросы.

1. Как можно подавить ошибку о том, что создающаяся директория уже существует?
2. C помощью какого флага можно создать необходимые директории, которые требуются для создания заданной директории?
3. Как в `grep` добавить вывод отображения номера строки при выводе совпадений с паттерном?

### Практическая часть

Напиши юнит-тест к какой-либо функции из вашего проекта. Сделайте ввод данных из `stdin`, а вывод теста направьте в `stdout`.
Подготовьте набор из нескольких файлов: входных данных и эталонных ответов.
Напишите команду, которая запустит ваш юнит-тест на всех данных и сравнит с выходными данными.
