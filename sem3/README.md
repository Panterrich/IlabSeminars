# 3. Системы сборки

## Введение

Когда вы пишите свои проекты, то зачем-то разбиваете их на файлы, некоторые из которых являются единицами трансляции (.с), а другие (.h) иклюдятся в другие файлы. Для чего это делается? В первую очередь, чтобы разделить логику и меньше держать контекста в голове. Работая по такому принципу, вы одновременно взаимодействуете с меньшим количеством
сущностей, это значительно облегчает написание кода.

Прежде чем переходить к сборке проекта, вспомним как компилятор узнает об именах.

<figure>
    <img src="images/names.png" alt="Связь имен">
</figure>

Итак, у нас есть файлы, которые объявляют имена, которые определяют имена и те, которые используют имена.

Есть два типа зависимостей, которые должны быть разрешены на разных стадиях сборки. Первый тип - стрелки из синих в черные блоки, должно быть разрешены на этапе компиляции. Второй тип - стрелки из черных черные блоки, должны быть разрешены на этапе линковки, определение должно слинковаться с использованием имени.

Имена могут быть объявлены, определены и затем использованы в рамках одного файла, но более типичная история, это когда нам необходимо переиспользовать функцию из другого модуля. Тогда мы декларацию функции (прототип) выносим в заголовочный файл. Определение функции кладем в какую-то единицу трансляции (.с), при этом в этом же файле указываем декларацию с помощью подключение заголовочного файла. Затем
в единице трансляции, где мы вызываем это функцию, также необходимо прокинуть декларацию функции: подключить соответствующий заголовочный файл.

Итак, мы узнали как у нас выглядит привычный принцип передачи имен компилятору для сборки.

## Project layout

Теперь перейден к типичному устройству репозитория проектов на С/C++. Как уже отмечалось ранее, все программисты стремятся сделать разделение на модули, поэтому любой проект представляет собой древовидную структуру, состоящая из модулей.

Модуль представляет собой набор исходников (единиц трансляции), которые лежат в директории с типичным названием `src` и набор публичных заголовочных файлов, которые лежат в директории `include`. Если модуль содержит тесты, то их также могут положить в директорию `test`.

Если репозиторий не является отдельной библиотекой, т.е. у него существует точка входа (функция main()), то её могут положить как в корень репозитория, так и в папку src корневого модуля.

Некоторые заголовочные файлы могут лежать внутри директории src, если они нужны только в рамках текущего модуля, и имена, хранящиеся в данном файле, не планируются экспортировать.

> [!NOTE]
> Если вы решили поделить файлы по указанной структуре, не забудьте, что можно не указывать самостоятельно относительные пути заголовочных файлов из директории `include`, а добавить флаг `-I` с указанием пути директории `include`, тогда компилятор будет искать заголовочные файлы и там.

## Системы сборки: уровень 0, bash-скрипт

Перейдем к системам сборки. Пусть для простоты у нас есть репозиторий с одним модулем. Нам необходимо собрать исполняемый файл нашей программы. Вы уже умеете компилировать программу с помощью командной строки, но чтобы каждый раз её не прописывать можно записать эту команду в файл и вызывать скрипт каждый раз по необходимости.

Пример:

```shell
#!/bin/bash

g++ src/arg_parser.cpp src/logger.cpp src/test_library.cpp \
src/buffer_clean.cpp src/main.cpp src/test_solve_quadr.cpp \
src/compare_double.cpp src/show_results.cpp src/get_data.cpp \
src/solve_quadr.cpp -Iinclude/ -std=c++17 -o square

```

> [!NOTE]
> Не забудьте сделать скрипт исполняемым с помощью команды `chmod +x build.sh`


Но давайте разобьём эту команду на шаги, которые компилятор сам выполняет в процессе, позже будет понятно зачем.

```shell
#!/bin/bash

FLAGS=""

g++ $FLAGS -c -I./include/ ./src/arg_parser.cpp -o arg_parser.o
g++ $FLAGS -c -I./include/ ./src/logger.cpp -o logger.o
g++ $FLAGS -c -I./include/ ./src/test_library.cpp -o test_library.o
g++ $FLAGS -c -I./include/ ./src/buffer_clean.cpp -o buffer_clean.o
g++ $FLAGS -c -I./include/ ./src/main.cpp -o main.o
g++ $FLAGS -c -I./include/ ./src/test_solve_quadr.cpp -o test_solve_quadr.o
g++ $FLAGS -c -I./include/ ./src/compare_double.cpp -o compare_double.o
g++ $FLAGS -c -I./include/ ./src/show_results.cpp -o show_results.o
g++ $FLAGS -c -I./include/ ./src/get_data.cpp -o get_data.o
g++ $FLAGS -c -I./include/ ./src/solve_quadr.cpp -o solve_quadr.o

g++ $FLAGS arg_parser.o logger.o test_library.o buffer_clean.o main.o \
 test_solve_quadr.o compare_double.o show_results.o get_data.o solve_quadr.o -o square

```

Т.е. сначала идет компиляция каждой единицы трансляции, затем идёт линковка всех полученных объектников (.o) в конечный исполняемый файл.

## Системы сборки: уровень 1, базовый makefile

Что здесь плохо в написанном выше скрипте? Мы пересобираем каждый раз весь проект. Если проект большой, то его полная пересборка измеряется часами. Часто в процессе разработки меняете только небольшую часть файлов, и соответственно необходимо пересобирать только те файлы, которые вы поменяли, и те файлы, которые зависели от них. Это существенно ускоряет пересборку проекта. Такой принцип называется **раздельной компиляцией**.

Что ещё нам не нравиться в предыдущем варианте? Язык bash-скриптов не декларативный: постоянно приходится описывать **как** сделать вместо того, чтобы указать **что** нужно сделать. Хочется просто описать зависимости файлов, а не процесс сборки.

На основе решений этих проблем был придуман Makefile.

Зависимости проекта, который можно собрать, всегда образуют **ациклический** однонаправленный граф. Это значит, что мы всегда можем описать файлы, те которые уже есть и те которые нужны. Makefile строит это граф, и запускает сборку в этом топологическом порядке, пересобирая только те цели, зависимости которых изменились.

Пример написания цели (target) следующий:

```
arg_parser.o: ./src/arg_parser.cpp
    g++ $(FLAGS) -c -I./include/ ./src/arg_parser.cpp -o arg_parser.o
```

> [!Warning]
> В Makefile обязательно используется табуляция.

Любая цель в Makefile считается файлом. Таким образом задаётся, что будет собирать данная цель и через двоеточие указываются все зависимости, а затем рецепт: как эту цель собрать.
