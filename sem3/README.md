# 3. Системы сборки

## Введение

Когда вы пишите свои проекты, то зачем-то разбиваете их на файлы, некоторые из которых являются единицами трансляции (.с), а другие (.h) иклюдятся в другие файлы. Для чего это делается? В первую очередь, чтобы разделить логику и меньше держать контекста в голове. Работая по такому принципу, вы одновременно взаимодействуете с меньшим количеством
сущностей, это значительно облегчает написание кода.

Прежде чем переходить к сборке проекта, вспомним как компилятор узнает об именах.

<figure>
    <img src="images/names.png" alt="Связь имен">
</figure>

Итак, у нас есть файлы, которые объявляют имена, которые определяют имена и те, которые используют имена.

Есть два типа зависимостей, которые должны быть разрешены на разных стадиях сборки. Первый тип - стрелки из синих в черные блоки, должно быть разрешены на этапе компиляции. Второй тип - стрелки из черных черные блоки, должны быть разрешены на этапе линковки, определение должно слинковаться с использованием имени.

Имена могут быть объявлены, определены и затем использованы в рамках одного файла, но более типичная история, это когда нам необходимо переиспользовать функцию из другого модуля. Тогда мы декларацию функции (прототип) выносим в заголовочный файл. Определение функции кладем в какую-то единицу трансляции (.с), при этом в этом же файле указываем декларацию с помощью подключение заголовочного файла. Затем
в единице трансляции, где мы вызываем это функцию, также необходимо прокинуть декларацию функции: подключить соответствующий заголовочный файл.

Итак, мы узнали как у нас выглядит привычный принцип передачи имен компилятору для сборки.

## Project layout

Теперь перейден к типичному устройству репозитория проектов на С/C++. Как уже отмечалось ранее, все программисты стремятся сделать разделение на модули, поэтому любой проект представляет собой древовидную структуру, состоящая из модулей.

Модуль представляет собой набор исходников (единиц трансляции), которые лежат в директории с типичным названием `src` и набор публичных заголовочных файлов, которые лежат в директории `include`. Если модуль содержит тесты, то их также могут положить в директорию `test`.

Если репозиторий не является отдельной библиотекой, т.е. у него существует точка входа (функция main()), то её могут положить как в корень репозитория, так и в папку src корневого модуля.

Некоторые заголовочные файлы могут лежать внутри директории src, если они нужны только в рамках текущего модуля, и имена, хранящиеся в данном файле, не планируются экспортировать.

> [!NOTE]
> Если вы решили поделить файлы по указанной структуре, не забудьте, что можно не указывать самостоятельно относительные пути заголовочных файлов из директории `include`, а добавить флаг `-I` с указанием пути директории `include`, тогда компилятор будет искать заголовочные файлы и там.

## Системы сборки: уровень 0, bash-скрипт

Перейдем к системам сборки. Пусть для простоты у нас есть репозиторий с одним модулем. Нам необходимо собрать исполняемый файл нашей программы. Вы уже умеете компилировать программу с помощью командной строки, но чтобы каждый раз её не прописывать можно записать эту команду в файл и вызывать скрипт каждый раз по необходимости.

Пример:

```shell
#!/bin/bash

g++ src/arg_parser.cpp src/logger.cpp src/test_library.cpp \
src/buffer_clean.cpp src/main.cpp src/test_solve_quadr.cpp \
src/compare_double.cpp src/show_results.cpp src/get_data.cpp \
src/solve_quadr.cpp -Iinclude/ -std=c++17 -o square

```

> [!NOTE]
> Не забудьте сделать скрипт исполняемым с помощью команды `chmod +x build.sh`


Но давайте разобьём эту команду на шаги, которые компилятор сам выполняет в процессе, позже будет понятно зачем.

```shell
#!/bin/bash

FLAGS=""

g++ $FLAGS -c -I./include/ ./src/arg_parser.cpp -o arg_parser.o
g++ $FLAGS -c -I./include/ ./src/logger.cpp -o logger.o
g++ $FLAGS -c -I./include/ ./src/test_library.cpp -o test_library.o
g++ $FLAGS -c -I./include/ ./src/buffer_clean.cpp -o buffer_clean.o
g++ $FLAGS -c -I./include/ ./src/main.cpp -o main.o
g++ $FLAGS -c -I./include/ ./src/test_solve_quadr.cpp -o test_solve_quadr.o
g++ $FLAGS -c -I./include/ ./src/compare_double.cpp -o compare_double.o
g++ $FLAGS -c -I./include/ ./src/show_results.cpp -o show_results.o
g++ $FLAGS -c -I./include/ ./src/get_data.cpp -o get_data.o
g++ $FLAGS -c -I./include/ ./src/solve_quadr.cpp -o solve_quadr.o

g++ $FLAGS arg_parser.o logger.o test_library.o buffer_clean.o main.o \
 test_solve_quadr.o compare_double.o show_results.o get_data.o solve_quadr.o -o square

```

Т.е. сначала идет компиляция каждой единицы трансляции, затем идёт линковка всех полученных объектников (.o) в конечный исполняемый файл.

## Системы сборки: уровень 1, базовый makefile

Что здесь плохо в написанном выше скрипте? Мы пересобираем каждый раз весь проект. Если проект большой, то его полная пересборка измеряется часами. Часто в процессе разработки меняете только небольшую часть файлов, и соответственно необходимо пересобирать только те файлы, которые вы поменяли, и те файлы, которые зависели от них. Это существенно ускоряет пересборку проекта. Такой принцип называется **раздельной компиляцией**.

Что ещё нам не нравиться в предыдущем варианте? Язык bash-скриптов не декларативный: постоянно приходится описывать **как** сделать вместо того, чтобы указать **что** нужно сделать. Хочется просто описать зависимости файлов, а не процесс сборки.

На основе решений этих проблем был придуман Makefile.

Зависимости проекта, который можно собрать, всегда образуют **ациклический** однонаправленный граф. Это значит, что мы всегда можем описать файлы, те которые уже есть и те которые нужны. Makefile строит это граф, и запускает сборку в этом топологическом порядке, пересобирая только те цели, зависимости которых изменились.

Пример написания цели (target) следующий:

```make
arg_parser.o: ./src/arg_parser.cpp
    g++ $(FLAGS) -c -I./include/ ./src/arg_parser.cpp -o arg_parser.o
```

Или в общем случае:

```make
<target>: [<requisites>]
    [shell commands]
```

Таким образом задаётся, что будет собирать данная цель и через двоеточие указываются все зависимости, а затем рецепт: как эту цель собрать.

> [!Warning]
> В Makefile обязательно используется табуляция.

Любая цель в Makefile по-умолчанию считается файлом, и make следит за датой обновления этого файла. Цель будет пересобираться, если изменился хотя бы один реквизит, либо если реквизита вообще нет.

Перепишем наш скрипт на makefile:

```make
FLAGS = -O2

all: arg_parser.o logger.o test_library.o buffer_clean.o main.o test_solve_quadr.o compare_double.o \
show_results.o get_data.o solve_quadr.o
	g++ $(FLAGS) arg_parser.o logger.o test_library.o buffer_clean.o main.o \
	test_solve_quadr.o compare_double.o show_results.o get_data.o solve_quadr.o -o square

arg_parser.o: ./src/arg_parser.cpp
	g++ $(FLAGS) -c -I./include/ ./src/arg_parser.cpp -o arg_parser.o

logger.o: ./src/logger.cpp
	g++ $(FLAGS) -c -I./include/ ./src/logger.cpp -o logger.o

test_library.o: ./src/logger.cpp
	g++ $(FLAGS) -c -I./include/ ./src/test_library.cpp -o test_library.o

buffer_clean.o: ./src/buffer_clean.cpp
	g++ $(FLAGS) -c -I./include/ ./src/buffer_clean.cpp -o buffer_clean.o

main.o: ./src/main.cpp
	g++ $(FLAGS) -c -I./include/ ./src/main.cpp -o main.o

test_solve_quadr.o: ./src/test_solve_quadr.cpp
	g++ $(FLAGS) -c -I./include/ ./src/test_solve_quadr.cpp -o test_solve_quadr.o

compare_double.o: ./src/compare_double.cpp
	g++ $(FLAGS) -c -I./include/ ./src/compare_double.cpp -o compare_double.o

show_results.o: ./src/show_results.cpp
	g++ $(FLAGS) -c -I./include/ ./src/show_results.cpp -o show_results.o

get_data.o: ./src/get_data.cpp
	g++ $(FLAGS) -c -I./include/ ./src/get_data.cpp -o get_data.o

solve_quadr.o: ./src/solve_quadr.cpp
	g++ $(FLAGS) -c -I./include/ ./src/solve_quadr.cpp -o solve_quadr.o
```

Отлично, но у нас теперь в нашей рабочей директории куча объектников. Давайте добавим в makefile следующую цель:

```make
clean:
    rm -rf *.o
```

Как уже говорилось ранее, clean будет считаться за файл, но так как его не существует и он не появляется при выполнении данной команды, то эта цель будет отрабатывать каждый раз.

Давайте перечислим некоторые проблемы данного makefile:

1. Компилятор прибит гвоздями к каждой команде. Хочется иметь возможность быстро подменить компилятор на другой.
2. Часто дублируется конструкция `-I./include`, можно вынести в переменную.
3. Если в проекте будет файл с именем `clean`, то таргет `clean` перестанет отрабатывать.
4. Много однотипных целей.

Исправим недоразумение с `clean`:

```make
.PHONY: clean
clean:
    rm -rf *.o
```

`PHONY` таргеты это специальные таргеты, которые не соответствуют никаким результирующим файлам. Обычно такими таргеты становятся по типу `all`, `clean`, `install`, `check` и другие. Рекомендуется помечать специальные таргеты так, чтобы случайный файл с таким именем в директории не помешал сборке.

### Переменные в Makefile

Переменные в Makefile занимают важную позицию. Они жестко прибиты в shell.
Есть некоторый список стандартных переменных предопределенных в make, которые необходимо рассмотреть:
1. $(CC) и $(CXX) - компиляторы С и C++
2. $(CFLAGS) и $(CXXFLAGS) - флаги компиляции С и С++
3. $(CPPFLAGS) - флаги препроцессора С
4. $(LDFLAGS) - флаги линковщика

Давайте разберемся со следующим примером

```make
bar = Hello $(baz)
baz = World
quux = $(baz)
qux = Hello $(quux)
quux = Make

.PHONY: all
all:
    @echo "bar = $(bar)"
    @echo "qux = $(qux)"
```

> [!Note]
> По умолчанию make показывает все исполняемые команды, иногда имеет смысл это подавить. Делается это с помощью `@` перед командой.

```
$ make -f lazy.mk
bar = Hello World
qux = Hello Make
```

Почему так? Переменные в makefile вычисляются лениво. Раскрытие переменных происходит в самый последний момент - в момент использования.

### Энергичные присвоения

А что будет выводиться в этом случае?

```make
bar := Hello $(baz)
baz := World

.PHONY: all
all:
    @echo "bar := $(bar)"
```

```
$ make -f energy.mk
bar := Hello
```

Неинициализированная переменная, которая используется в энергичном присвоении, будет пустой строкой.

Чтобы записать, дописать или переписать переменную, заданную снаружи, надо указать override.

```make
override CFLAGS += -I./include

.PHONY: all
all:
    @echo $(CFLAGS)
```

```
$ make CFLAGS="-g -O0"
-g -O0 -I./include
```

### Параллельность в makefile
Давайте посмотрим следующий пример:

```make
SUBDIRS = foo bar baz

.PHONY: subdirs
subdirs:
    for dir in $(SUBDIRS); do \
        $(MAKE) -C $dir; \
    done
```

Команда `make -C $dir` запускает рекурсивно makefile в указанной директории. Makefile можно запускать параллельно с помощью флага `-jN`, где `N` - количество воркеров (обычно ставят не больше числа потоков, учитывая количество оперативной памяти). В данном случае параллельность была утеряна, так как make не знает о зависимостях и последовательно запускает рекурсивный make, а также теряется сообщение об ошибках внутри запуска makefile.

Перепишим следующим образом:

```make
SUBDIRS = foo bar baz

.PHONY: subdirs
subdirs: $(SUBDIRS)

.PHONY: $(SUBDIRS)
$(SUBDIRS):
    @$(MAKE) -C $@
```

> [!Note]
> `$@` - автоматическая переменная, которая означает имя цели.

Получаем, что список директорий задаёт несколько псевдоцелей, каждый из которых вызывает соответствующий make, и есть псевдоцель, которая зависит от списка этих псевдоцелей.

Если запустить make c флагом `-k`, то make будет игнорировать ошибки и пытаться собрать всё, что может.

### Автоматические переменные

Мы уже успели познакомиться с автоматической переменной `$@`. Рассмотрим другой пример, который избавит нас от другой упомянутой проблемы:

```make
arg_parser.o: ./src/arg_parser.cpp
	g++ $(CFLAGS) -c $^ -o $@
```

1. `$@` - имя таргета
2. `$^` - имена всех реквизитов
3. `$<` - имя первого реквизита
4. `$(@D)` - часть имени относящаяся к директории
5. `$(@F)` - часть имени относящаяся к файлу

## Системы сборки: уровень 2, любительский makefile

Объединяем предыдущие результаты и получаем:

```make
CC = gcc
CFLAGS ?= -O2
COMMONOTIC = -I./include

override CFLAGS += $(COMMONOTIC)

.PHONY: all
all: square

square: arg_parser.o logger.o test_library.o buffer_clean.o main.o test_solve_quadr.o compare_double.o \
show_results.o get_data.o solve_quadr.o
    $(CC) $^ -o $@ $(LDFLAGS)

arg_parser.o: ./src/arg_parser.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

logger.o: ./src/logger.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

test_library.o: ./src/logger.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

buffer_clean.o: ./src/buffer_clean.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

main.o: ./src/main.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

test_solve_quadr.o: ./src/test_solve_quadr.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

compare_double.o: ./src/compare_double.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

show_results.o: ./src/show_results.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

get_data.o: ./src/get_data.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

solve_quadr.o: ./src/solve_quadr.cpp
	$(CC) $(CFLAGS) -c $^ -o $@

.PHONY: clean
clean:
    rm -rf *.o
```

### Функции в makefile


## Советы

1. Используйте стандартные переменные для компиляторов, линкеров и т.д.
2. Используйте также стандартные переменные для флагов.
3. Помечайте PHONY те таргеты, которые не соответствуют файлам.
4. Используйте override, если вы предполагаете, что переменная задаётся извне.
5. Не пишите сложные shell-скрипты внутри makefiles.
6. Используйте автоматические переменные.

## Самостоятельная работа

1. Напишите самостоятельно универсальный makefile, в котором необходимо менять минимальное количество вещей, при переходе на другой проект.
2. Попытайтесь написать makefile для нескольких отдельных модулей и написать общий makefile.
3. Добавьте несколько режимов сборки проектов: Release (`-O2`) и Debug (`-g3 -O0`).
